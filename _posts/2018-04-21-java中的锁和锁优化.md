---
title: java中的锁和锁优化
date: 2018-04-21
categories: java
tags:
- synchronized
- Reentrantlock
- 锁
---



我们在Java中常用到用于同步的锁有synchronized和ReentrantLock下面介绍一下他们。



<!---begin--->



## ReentrantLock

### 介绍：

reentrantlock是java中内置的一种锁，他中文直译就是可重入锁，所以他肯定是可重入的，而且他是独享锁，它可以修改成公平锁或者非公平锁。相比synchronized 他有可中断，可限时的优点。但是他也比synchronized复杂。

### 用法：

```java
public static ReentrantLock lock = new ReentrantLock();
public static ReentrantLock lock =  ReentrantLock(boolean fair);//获取公平非公平锁
lock.tryLock(long timeout, TimeUnit unit)//限时获取锁
```



## synchronized

### 介绍：

synchronized是一个关键字，用于线程之间的同步，它可以对方法，代码块进行加锁，它是一个非公平锁，可重入。java1.6对他进行了优化，让它的性能比肩ReentrantLock。

### 用法：

修饰代码块：

```java
synchronized(this){//获取的是对象锁，相同对象之间竞争同一个锁
    代码………………
}
```

修饰方法：

```java
public synchronized void method(){//获取的是对象锁，相同对象之间竞争同一个锁
   代码………………
}
public static synchronized void method(){//获取到的是类锁，相同类之间竞争一个锁
   代码………………
}
```

修饰类：

```java
class ClassName {
   public void method() {
      synchronized(ClassName.class) {//获取到的是类锁，相同类之间竞争一个锁
         代码………………
      }
   }
}
```

### 锁优化：

synchronized 一共有4种状态，分别是无锁，偏向锁，轻量级锁，重量级锁。锁的状态只能升级不能降级。

轻量级锁是指锁之间通过自旋获取锁，优点是响应快，缺点是消耗CPU在无谓的自旋上。

重量级锁通过阻塞等待锁，优点是CPU影响少，缺点是响应性差。

概念：	自旋：通过循环获取锁。

​		monitor：监视锁，synchronized底层实现的锁。

​		lock record：锁记录，方法区中方法栈栈帧中一个用于存储锁的空间。

​		CAS：原子操作。

​		mark word：标记同步，是在堆中对象头的一部分，默认存储对象的HashCode，分代年龄和锁标记位。

##### 偏向锁：

大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。这就是偏向锁，优点是再次获取锁的消耗微乎其微，缺点是竞争消耗大。

获取过程：如果无锁状态，修改成偏向锁，将对象头中的mark word中的线程id指向自己，如果成功则成功获取锁，可以同步。 如果失败，则表明有其他线程获取锁，将等待全局安全点将锁升级。

偏向锁无需解锁，一直持有。

##### 轻量级锁：

线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，则自旋获取锁，当自旋获取锁仍然失败时，表示存在其他线程竞争锁(两条或两条以上的线程竞争同一个锁)，则轻量级锁会膨胀成重量级锁。

轻量级解锁时，会使用原子的CAS操作来将Displaced Mark Word替换回到对象头，如果成功，则表示同步过程已完成。如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。

##### 重量级锁：

重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex互斥的功能，它还负责实现了Semaphore的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。

##### 其他锁优化：

适应性自旋：如果通过自旋整个获取锁，增加下自自旋次数，如果失败，减少下次自旋次数。

锁粗化：将连续的加锁解锁变成一个大的锁，将[加解加解加解加解]优化成[加--------解]。

锁消除：如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。



