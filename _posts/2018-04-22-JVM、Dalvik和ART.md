---
title: JVM、Dalvik和ART
date: 2018-04-22
categories: android
tags:
- JVM
- android
---



JVM、Dalvik和ART



<!---begin--->

### JVM和DVM的区别

JVM是Java Virtual Machine，而DVM就是Dalvik Virtual Machine，是安卓中使用的虚拟机，所有安卓程序都运行在安卓系统进程里，每个进程对应着一个Dalvik虚拟机实例。他们都提供了对象生命周期管理、堆栈管理、线程管理、安全和异常管理以及垃圾回收等重要功能，**各自拥有一套完整的指令系统**，以下简要对比两种虚拟机的不同。

**①JAVA虚拟机运行的是JAVA字节码，Dalvik虚拟机运行的是Dalvik字节码**

JAVA程序经过编译，生成JAVA字节码保存在class文件中，JVM通过解码class文件中的内容来运行程序。而DVM运行的是Dalvik字节码，所有的Dalvik字节码由JAVA字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中，DVM通过解释DEX文件来执行这些字节码。

DVM使用dex文件的原因：

> class文件中包含多个不同的方法签名，如果A类文件引用B类文件中的方法，方法签名也会被复制到A类文件中（在虚拟机加载类的连接阶段将会使用该签名链接到B类的对应方法），也就是说，多个不同的类会同时包含相同的方法签名，同样地，大量的字符串常量在多个类文件中也被重复使用，这些冗余信息会直接增加文件的体积，而JVM在把描述类的数据从class文件加载到内存时，需要对数据进行校验、转换解析和初始化，最终才形成可以被虚拟机直接使用的JAVA类型，因为大量的冗余信息，会严重影响虚拟机解析文件的效率。
>
> 为了减小执行文件的体积，安卓使用Dalvik虚拟机，SDK中有个dx工具负责将JAVA字节码转换为Dalvik字节码，dx工具对JAVA类文件重新排列，将所有JAVA类文件中的常量池分解，消除其中的冗余信息，重新组合形成一个常量池，所有的类文件共享同一个常量池，使得相同的字符串、常量在DEX文件中只出现一次，从而减小了文件的体积。

![文件](https://upload-images.jianshu.io/upload_images/1716536-d7de98cfb5793fc0.png)



**②JVM基于栈，DVM基于寄存器**

基于栈的虚拟机在栈帧中有个操作数栈，基于栈的意思就是基于这个栈，比如说实现a=b+c，代码是push b ,push c ,add ,pop a;它在整个过程理论上不会用到寄存器（因为处于可移植性的原因，不是所有的硬件平台都有寄存器，但是也会对有寄存器的硬件平台优化）。

关于栈式虚拟机有以下特点：
1.代码必须使用这些指令来移动变量(即push和pop)
2.代码尺寸小和解码效率会更高些
3.堆栈虚拟机指令有隐含的操作数。

而基于寄存器的虚拟机，没有操作数，有很多虚拟寄存器，但是这些虚拟寄存器不一定在真实的寄存器上（也是为了可移植性）函数的所有局部变量都各占据一个寄存器。因此，存取局部变量是相当高效的。

关于寄存器式虚拟机有以下特点：
1.使用堆栈来分配激活记录器
2.基于寄存器代码免去了使用push和pop命令的麻烦，减少了每个函数的指令总数。
3.代码尺寸和解码效率不如基于栈虚拟机，因为它包含操作数，所以指令大于基于堆栈的指令。但是基于寄存器产生更少的代码，所以总的代码数不会增加。
4.寄存器虚拟机必须从操作指令中解码操作数，需要额外的解码操作。



基于栈与基于寄存器的指令集，用在解释器里，笼统说有以下对比：

- 从源码生成代码的难度：基于栈 < 基于寄存器，不过差别不是特别大
- 表示同样程序逻辑的**代码大小**（code size）：基于栈 < 基于寄存器
- 表示同样程序逻辑的指**令条数**（instruction count）：基于栈 > 基于寄存器
- 简易实现中数据移动次数（data movement count）：基于栈 > 基于寄存器；不过值得一提的是实现时通过栈顶缓存（top-of-stack caching）可以大幅降低基于栈的解释器的数据移动开销，可以让这部分开销跟基于寄存器的在同等水平。
- 采用同等优化程度的解释器速度：基于栈 < 基于寄存器
- 交由同等优化程度的JIT编译器编译后生成的代码速度：基于栈 === 基于寄存器

因而，笼统说可以有以下结论：

- 要追求尽量实现简单：选择基于栈
- 传输代码的大小尽量小：选择基于栈
- 纯解释执行的解释器的速度：选择基于寄存器
- 带有JIT编译器的执行引擎的速度：随便，两者一样；对简易JIT编译器而言基于栈的指令集可能反而更便于生成更快的代码，而对比较优化的JIT编译器而言输入是基于栈还是基于寄存器都无所谓，经过parse之后就变得完全一样了。

### 什么是ART虚拟机，和JVM/DVM有什么不同？

首先了解JIT（Just In Time，即时编译技术）和AOT(Ahead Of Time，预编译技术)两种编译模式。

JIT以JVM为例，javac把程序源码编译成JAVA字节码，JVM通过逐条解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译，执行速度必然比C/C++编译后的可执行二进制字节码程序慢，为了提高执行速度，就引入了JIT技术，JIT会在运行时分析应用程序的代码，识别哪些方法可以归类为热方法，这些方法会被JIT编译器编译成对应的汇编代码，然后存储到代码缓存中，以后调用这些方法时就不用解释执行了，可以直接使用代码缓存中已编译好的汇编代码。这能显著提升应用程序的执行效率。（安卓Dalvik虚拟机在2.2中增加了JIT）

相对的AOT就是指C/C++这类语言，编译器在编译时直接将程序源码编译成目标机器码，运行时直接运行机器码。

**Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码**

Dalvik执行的是dex字节码，依靠JIT编译器去解释执行，运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后在执行，但是将dex字节码翻译成本地机器码是发生在应用程序的运行过程中，并且应用程序每一次重新运行的时候，都要重新做这个翻译工作，因此，及时采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。

安卓运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者重新将自己的应用直接编译成目标机器码，也就是说，应用程序仍然是一个包含dex字节码的apk文件。所以在安装应用的时候，dex中的字节码将被编译成本地机器码，之后每次打开应用，执行的都是本地机器码。移除了运行时的解释执行，效率更高，启动更快。（安卓在4.4中发布了ART运行时）

ART优点：

> ①系统性能显著提升
> ②应用启动更快、运行更快、体验更流畅、触感反馈更及时
> ③续航能力提升
> ④支持更低的硬件

ART缺点

> ①更大的存储空间占用，可能增加10%-20%
> ②更长的应用安装时间

总的来说ART就是“空间换时间”