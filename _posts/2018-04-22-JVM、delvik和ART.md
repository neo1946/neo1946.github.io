---
title: JVM、delvik和ART
date: 2018-04-22
categories: android
tags:
- JVM
- android
---



JVM、delvik和ART



<!---begin--->



### GC：

GC：Garbage Collection 垃圾收集，java用专门的线程来进行内存管理，将无用的内存进行释放，不用程序员自行管理。

GC区域：线程私有的3个区域因为跟随线程生命周期，不用过多考虑回收问题。GC主要在于java堆和方法区。



### 存活分析：

##### 引用计数算法：

给对象添加一个引用计数器，每当被引用的时候就将计数器加一，当对象没有被引用的时候就表示这个对象不在会被使用也就是死掉了。

引用计数算法简单，容易实现，但是无法检测互相引用的情况，所以很少被使用。

##### 根搜索算法：

从根开始遍历引用链，无法被引用链引用到的对象就不会再使用。

在JAVA语言中，可以当做GC roots的对象有以下几种：

> **1、栈（栈帧中的本地变量表）中引用的对象。**
>
> **2、方法区中的静态成员。**
>
> **3、方法区中的常量引用的对象（全局变量）**
>
> **4、本地方法栈中JNI（一般说的Native方法）引用的对象。**



### 垃圾搜集算法：

##### 标记-清除算法：

标记清除就是用根搜索算法，将可达的对象标记为存活对象，遍历完后将没有标记的对象清除。

标记清除算法在内存被耗尽的情况下会触发标记程序，然后清理完之后再恢复运行。

他的缺点是效率比较低，stop the world事件比较长，要递归和全堆对象遍历。 而且这样清除出来的空间不连续。

##### 复制算法：（新生代的GC）

将内存空间分成2块，也用根搜索算法，将存活的对象复制到另一块内存块中，将这块内存全部清空。

算法的优点在于实现简单，运行高效，但是会造成很大的空间浪费，所以我们一般虚拟机将新生代分成3部分，Eden和2块Survivor，大概是8：1：1。将Eden和一块Survivor存活对象复制到另一块Survivor块中，清理Eden和用过的Survivor。这样就只有10%的空间浪费，但是过小的Survivor空间可能不够用，需要依赖老年代进行**分配担保**，大对象直接进入老年代。

##### 标记-整理算法：（老年代的GC）

如果对象的存活率很高，用复制算法会导致很多的复制操作，大大降低效率，也会造成空间浪费。

标记-整理（压缩）算法适用于存货对象比较多的场合，它先做一次可达性分析，将所有存活对象复制到内存的一段，然后将其余的空间全部清除。

算法的优点在于不浪费空间，也不会造成内存碎片化，缺点是效率不高，因为它要整理存活对象的引用地址，移动到内存一侧。

##### 分代收集算法：（新生代的GC+老年代的GC）

当前商业虚拟机的GC都是采用的“分代收集算法”，这并不是什么新的思想，只是根据对象的存活周期的不同将内存划分为几块儿。一般是把Java堆分为新生代和老年代：短命对象归为新生代，长命对象归为老年代。

少量对象存活，适合复制算法：在新生代中，每次GC时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。

大量对象存活，适合用标记-清理/标记-整理：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。



### 垃圾收集器：

垃圾收集器分成新生代和老年代的收集器：

用到的概念：

**并发和并行**
这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语	境中，它们可以解释如下。

**并行（Parallel）**：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。

**并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。





**Minor GC 和 Full GC**

**新生代GC（Minor GC）**：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。

**老年代GC（Major GC / Full GC）**：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

**吞吐量**
吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。
虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。



#### Serial：（新生代）

Serial（**串行**）垃圾收集器是最基本、发展历史最悠久的收集器； JDK1.3.1前是HotSpot新生代收集的唯一选择；

特点：
针对新生代；
采用**复制**算法；
单线程收集；
进行垃圾收集时，必须暂停所有工作线程，直到完成，即会"Stop The World"（下称STW）；



优点：实现简单，没有线程切换开销，在单处理器或者性能较差的硬件平台表现优秀。

缺点：单线程收集，浪费硬件资源（针对），全过程STW卡顿严重。

#### ParNew：（新生代）

ParNew垃圾收集器工作在新生代的垃圾收集器，它只简单地将串行回收器多线程化（**并行**）。它的回收策略、算法以及参数和串行回收器一样。

特点
除了多线程外，其余的行为、特点和Serial收集器一样；
如Serial收集器可用控制参数、收集算法、Stop The World、内存分配规则、回收策略（**复制**）等；
两个收集器共用了不少代码；

#### Parallel Scavenge：（新生代）

Parallel Scavenge收集器是是使用复制算法的收集器，又是**并行**的多线程收集器。与ParNew类似，但它有一个GC自适应调节策略。

特点
（A）、有一些特点与ParNew收集器相似
      新生代收集器；
      采用**复制**算法；
      多线程收集；
（B）、主要特点是：它的关注点与其他收集器不同
      CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达一个可控制的吞吐量（Throughput）；

​	Parallel Scavenge收集器与ParNew收集器的一个重要区别是它具有自适应调节策略。

**GC自适应的调节策略**：

Parallel Scavenge收集器有一个参数-`XX:+UseAdaptiveSizePolicy`。当这个参数打开之后，就不需要手工指定新生代的大小、Eden与Survivor区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。

#### Serial Old：（老年代）

Serial Old垃圾收集器和Serial 一样是**串行**的独占式的垃圾收集器，针对老年代它采用标记-整理算法。优缺点和Serial类似。

特点
针对老年代；
采用"**标记-整理**"算法（还有压缩，Mark-Sweep-Compact）；
单线程收集；

#### Parallel Old：（老年代）

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程（**并行**）和**“标记－整理”**算法。

特点
针对老年代；
采用"标记-整理"算法；
多线程收集；

#### cms：（老年代）

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

1、特点
      针对老年代；
      基于"**标记-清除**"算法(不进行压缩操作，产生内存碎片)；      
      以获取最短回收停顿时间为目标；
      **并发**收集、低停顿；
      需要更多的内存；



CMS收集器3个明显的缺点
（A）、对CPU资源非常敏感
      并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。
      CMS的默认收集线程数量是=(CPU数量+3)/4；
      当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。
B）、无法处理浮动垃圾,可能出现"Concurrent Mode Failure"失败
（1）、浮动垃圾（Floating Garbage）
      在并发清除时，用户线程新产生的垃圾，称为浮动垃圾；
      这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集；
      也要可以认为CMS所需要的空间比其他垃圾收集器大；
"-XX:CMSInitiatingOccupancyFraction"：设置CMS预留内存空间；
      JDK1.5默认值为68%；
      JDK1.6变为大约92%；               

（2）、"Concurrent Mode Failure"失败
      如果CMS预留内存空间无法满足程序需要，就会出现一次"Concurrent Mode Failure"失败；
      这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生；
      这样的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置得太大。
（C）、产生大量内存碎片
      由于CMS基于"标记-清除"算法，清除后不进行压缩操作；
      产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作。

#### G1：（整堆）

G1（Garbage-First）是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。

1、特点
（A）并行与并发**
      能充分利用多CPU、多核环境下的硬件优势；
      可以并行来缩短"Stop The World"停顿时间；
      也可以并发让垃圾收集与用户程序同时进行；
（B）分代收集，收集范围包括**新生代和老年代**    
      能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；
      能够采用不同方式处理不同时期的对象；
      虽然保留分代概念，但Java堆的内存布局有很大差别；
      将整个堆划分为多个大小相等的独立区域（Region）；
      新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合；
（C）结合**多种垃圾收集算法**，空间整合，不产生碎片
      从整体看，是基于标记-整理算法；
      从局部（两个Region间）看，是基于复制算法；
      这是一种类似火车算法的实现；
      都不会产生内存碎片，有利于长时间运行；
（D）可预测的停顿：低停顿的同时实现高吞吐量

### 搭配：

![搭配](https://upload-images.jianshu.io/upload_images/650075-8c5080659578032d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/547)



### 安卓虚拟机垃圾回收：

1.Dalvik 

  Dalvik的垃圾回收分为两个阶段。

  第一个阶段，Dalvik暂停所有的线程来分析堆的使用情况。

  第二个阶段，Dalvik暂停所有线程来清理堆。这就会导致应用在性能上的“卡顿”。

  2.ART 

  ART改进后的垃圾回收算法**只暂停线程一次**。ART 能够做到这一点，是因为应用本身做了垃圾回收的一些工作。垃圾回收启动后，不再是两次暂停，而是一次暂停。在遍历阶段，应用不需要暂停，同时垃圾回收停时间也大大缩短，因为 Google使用了一种新技术（packard pre-cleaning），在暂停前就做了许多事情，减轻了暂停时的工作量。